#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <cstdlib>
#include <algorithm>
#include <iomanip>
using namespace std;

struct node
{
    string name; // ?????????
    int Ctime;   // ?????????????????????
    int Rtime;   // ?????????????????
    int Stime;   // ?????????§Ö????
    int Etime;   // ??????§ß????????
    int Ttime;   // ?????????
    float Wtime; // ????????????
};

int Timestamp(string time) // ???????
{
    int pos = time.find_last_of(':'); // ??????????????§³??????

    string s1 = time.substr(0, pos); // ???§³??????????
    string s2 = time.substr(pos + 1);

    int n1 = stoi(s1); // ????????
    int n2 = stoi(s2);

    return n1 * 60 + n2; // ?????????????
}

void p_Timestamp(int time)
{
    cout << setw(2) << setfill('0') << time / 60 << ":"
         << setw(2) << setfill('0') << time % 60 << "\t";
}

void FCFS(int batchsize, vector<node> &work)
{
    queue<int> q;
    vector<int> batch(batchsize + 1);
    int work_id = 1;
    int work_num = work.size() - 1;
    int now_time = 0; // ?????
    while (work_id <= work_num || !q.empty())
    {
        now_time++;
        while (work_id <= work_num && now_time >= work[work_id].Ctime)
        { // ?§Ø?????????????§Ö??????
            q.push(work_id);
            work_id++;
        }

        for (int i = 1; i <= batchsize; i++)
        { // ?§Ø?????????§á??§Ö???????????
            if (now_time >= batch[i] && !q.empty())
            { // ????§á???????????????????§Ó????????????????????????
                int idx = q.front();
                q.pop();
                work[idx].Stime = now_time;
                work[idx].Etime = now_time + work[idx].Rtime;
                work[idx].Ttime = work[idx].Etime - work[idx].Ctime;
                work[idx].Wtime = work[idx].Ttime * 1.0 / work[idx].Rtime;
                batch[i] = work[idx].Etime;
            }
        }
    }
};

void SJF(int batchsize, vector<node> &work)
{
    int work_num = work.size() - 1;
    vector<int> batch(batchsize + 1);
    auto compareshort = [&](int x, int y)
    {
        return work[x].Rtime > work[y].Rtime;
    };
    priority_queue<int, vector<int>, decltype(compareshort)> q(compareshort);
    int work_id = 1;
    int now_time = 0; // ?????
    while (work_id <= work_num || !q.empty())
    {
        now_time++;
        while (work_id <= work_num && now_time >= work[work_id].Ctime)
        { // ?§Ø?????????????§Ö??????
            q.push(work_id);
            work_id++;
        }

        for (int i = 1; i <= batchsize; i++)
        { // ?§Ø?????????§á??§Ö???????????
            if (now_time >= batch[i] && !q.empty())
            { // ????§á???????????????????§Ó????????????????????????
                int idx = q.top();
                q.pop();
                work[idx].Stime = now_time;
                work[idx].Etime = now_time + work[idx].Rtime;
                work[idx].Ttime = work[idx].Etime - work[idx].Ctime;
                work[idx].Wtime = work[idx].Ttime * 1.0 / work[idx].Rtime;
                batch[i] = work[idx].Etime;
            }
        }
    }
};

void HRN(int batchsize, vector<node> &work)
{
    int work_num = work.size() - 1;
    vector<int> batch(batchsize + 1);
    int now_time = 0; // ?????
    auto compare = [&](int x, int y)
    {
        return (now_time - work[x].Ctime) * (work[y].Rtime) < (now_time - work[y].Ctime) * (work[x].Rtime);
    }; // ????????????????(????????? / ?????????)

    priority_queue<int, vector<int>, decltype(compare)> q(compare);
    int work_id = 1;
    while (work_id <= work_num || !q.empty())
    {
        now_time++;
        while (work_id <= work_num && now_time >= work[work_id].Ctime)
        { // ?§Ø?????????????§Ö??????
            q.push(work_id);
            work_id++;
        }

        for (int i = 1; i <= batchsize; i++)
        { // ?§Ø?????????§á??§Ö???????????
            if (now_time >= batch[i] && !q.empty())
            { // ????§á???????????????????§Ó????????????????????????
                int idx = q.top();
                q.pop();
                work[idx].Stime = now_time;
                work[idx].Etime = now_time + work[idx].Rtime;
                work[idx].Ttime = work[idx].Etime - work[idx].Ctime;
                work[idx].Wtime = work[idx].Ttime * 1.0 / work[idx].Rtime;
                batch[i] = work[idx].Etime;
            }
        }
    }
};

vector<node> DataDeal()
{
    cout << "?????????????????????: ";
    int task_num;
    cin >> task_num; // ???????????????????
    vector<node> work(task_num + 1);

    string time;
    cout << "????????????????????????? \n"; // ?????????????????????

    for (int i = 1; i <= task_num; ++i)
    {
        cin >> work[i].name;             // ????????????
        cin >> time;                     // ??????????????
        work[i].Ctime = Timestamp(time); // ???????????????????????›¥
        cin >> work[i].Rtime;            // ??????????
    }

    // ??????????????????????????lambda????
    sort(&work[1], &work[task_num + 1], [](node a, node b)
         { return a.Ctime < b.Ctime; });
    return work;
}

void PrintResults(string info, int batchsize, vector<node> work)
{
    int SumTtime = 0;
    float SumWtime = 0;
    int work_num = work.size() - 1;
    cout << info << ", ?????: " << batchsize << "?????: " << endl;
    cout << "name\tCtime\tRtime\tStime\tEtime\tTtime\tWtime" << endl;
    for (int i = 1; i <= work_num; i++)
    {
        cout << work[i].name << "\t";
        p_Timestamp(work[i].Ctime);
        cout << work[i].Rtime << "\t";
        p_Timestamp(work[i].Stime);
        p_Timestamp(work[i].Etime);
        cout << work[i].Ttime << "\t";
        cout << fixed << setprecision(3) << work[i].Wtime << endl;
        SumTtime += work[i].Ttime;
        SumWtime += work[i].Wtime;
    }
    cout << endl;
    cout << "?????????: " << SumTtime * 1.0 / work_num << endl;
    cout << "????????????: " << SumWtime * 1.0 / work_num << endl;
    cout << endl;
}

void run(void (*func)(int, vector<node> &), int batchsize, string info)
{
    vector<node> work = DataDeal();
    func(batchsize, work);
    PrintResults(info, batchsize, work);
}

void runAll(int batchsize)
{
    vector<node> work = DataDeal();
    FCFS(batchsize, work);
    PrintResults("???????????", batchsize, work);
    SJF(batchsize, work);
    PrintResults("???????????", batchsize, work);
    HRN(batchsize, work);
    PrintResults("??????????", batchsize, work);
}

void menu()
{
    cout << "********************\n";
    cout << "????????????????\n";
    cout << "1.???????????\n";
    cout << "2.???????????\n";
    cout << "3.??????????\n";
    cout << "4.??????????\n";
    cout << "0.???????\n\n";
    cout << "????????????: ";
    int op, batchsize;
    cin >> op;
    cout << "????????????????: ";
    cin >> batchsize;
    switch (op)
    {
    case 0:
        exit(0);
    case 1:
        run(FCFS, batchsize, "???????????");
        break; // ????????????????
    case 2:
        run(SJF, batchsize, "???????????");
        break; // ?????????????????
    case 3:
        run(HRN, batchsize, "??????????");
        break; // ???????????????
    case 4:
        runAll(batchsize);
        break;
    default:
        cout << "\n?????§¹\n\n";
    }
}

int main()
{
    while (1)
    {
        menu();
    }
    return 0;
}

/*
1 8:00 50
2 8:15 30
3 8:30 25
4 8:35 20
5 8:45 15
6 9:00 10
7 9:20 5
*/
